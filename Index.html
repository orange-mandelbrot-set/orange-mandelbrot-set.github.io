<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Command Queue Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #1a202c;
            color: #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }

        /* The user should replace this with their desired texture/illustration */
        #game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(16, 1fr);
            width: 350px; /* 10 columns * 35px */
            height: 560px; /* 16 rows * 35px */
            position: relative;
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            /* Placeholder background - replace with your own image url */
            background-image: url('assets/map.jpg');
            background-size: cover;
        }

        .tile {
            width: 35px;
            height: 35px;
            box-sizing: border-box;
            /* Faint border for debugging/grid visibility */
            border: 1px solid rgba(128, 128, 128, 0.2); 
            background-color: transparent; /* Tiles are now transparent */
        }

        /* Wall class is now only for logic, not visuals */
        .wall {
            /* No visual style */
        }

        /* Target class is now only for logic, not visuals */
        .target {
            /* No visual style */
        }

        .target-affected {
            background-color: rgba(104, 211, 145, 0.7); /* Green glow for win condition */
            animation: pulse 1s infinite;
            border-radius: 50%;
        }

        @keyframes pulse {
            0% { transform: scale(0.5); box-shadow: 0 0 0 0 rgba(104, 211, 145, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 10px 15px rgba(104, 211, 145, 0); }
            100% { transform: scale(0.5); box-shadow: 0 0 0 0 rgba(104, 211, 145, 0); }
        }

        #player {
            position: absolute;
            width: 35px;
            height: 35px;
            /* A simple, clean sprite. Can be replaced with any image URL. */
            background-image: url('assets/player.jpg');
            background-size: 70%;
            background-position: center;
            background-repeat: no-repeat;
            transition: top 0.3s linear, left 0.3s linear, transform 0.3s ease-in-out;
            z-index: 10;
        }

        /* Modal for win message */
        #win-modal {
            transition: opacity 0.3s ease-in-out;
        }
        
        /* Ensure emoji icons are large and centered */
        .icon-btn {
            font-size: 1.5rem;
            line-height: 1;
        }
    </style>
</head>
<body class="bg-gray-900">

    <div class="flex flex-col lg:flex-row gap-8 items-center">
        <!-- Game Board -->
        <div id="game-board-container" class="p-4 bg-gray-800 rounded-lg shadow-2xl">
            <div id="game-board">
                <!-- Tiles will be generated by JavaScript -->
                <div id="player"></div>
            </div>
        </div>

        <!-- Interface -->
        <div class="w-full lg:w-64 bg-gray-800 p-6 rounded-lg shadow-2xl flex flex-col gap-4">
            <h1 class="text-2xl font-bold text-center text-white">Controls</h1>
            
            <!-- Command Buttons -->
            <div class="grid grid-cols-2 gap-3">
                <button id="btn-move" class="icon-btn bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">‚Üë</button>
                <button id="btn-affect" class="icon-btn bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">üí•</button>
                <button id="btn-rotL" class="icon-btn bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">‚Ü∂</button>
                <button id="btn-rotR" class="icon-btn bg-teal-500 hover:bg-teal-600 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">‚Ü∑</button>
            </div>

            <!-- Command Queue Display -->
            <div>
                <h2 class="text-lg font-bold mb-2 text-center text-gray-300">Command Queue</h2>
                <div id="queue-display" class="bg-gray-900 rounded-lg p-3 min-h-[100px] text-center text-gray-400 overflow-y-auto max-h-48 flex flex-wrap justify-center items-center gap-1">
                    Queue is empty.
                </div>
            </div>

            <!-- Execution Controls -->
            <div class="flex items-center gap-2">
                <button id="btn-run" class="icon-btn flex-grow bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">‚ñ∂Ô∏è</button>
                <button id="btn-clear" class="icon-btn bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition-transform transform hover:scale-105">‚õî</button>
            </div>
        </div>
    </div>

    <!-- Win Modal -->
    <div id="win-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden opacity-0">
        <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center">
            <h2 class="text-4xl font-bold text-green-400 mb-4">Target Affected!</h2>
            <p class="text-xl text-gray-300">You've completed the objective!</p>
            <button id="btn-reset" class="mt-6 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">Play Again</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- GAME CONFIGURATION ---
            const GRID_WIDTH = 10;
            const GRID_HEIGHT = 16;
            const TILE_SIZE = 35; // In pixels

		// Tile types: 0=Empty, 1=Wall, 2=Start, 3=Target
            const tileData = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 0, 0, 0, 0, 0, 2, 1],
                [1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 0, 1, 1],
                [1, 1, 0, 0, 1, 1, 0, 3, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†];

            // --- DOM ELEMENTS ---
            const gameBoard = document.getElementById('game-board');
            const playerElement = document.getElementById('player');
            const queueDisplay = document.getElementById('queue-display');
            const winModal = document.getElementById('win-modal');

            // --- GAME STATE ---
            let player = { x: 1, y: 1, dir: 0 }; // dir: 0=Up, 1=Right, 2=Down, 3=Left
            let commandQueue = [];
            let isExecuting = false;

            // --- FUNCTIONS ---

            /**
             * Initializes the game board by creating tile elements.
             */
            function createBoard() {
                gameBoard.innerHTML = ''; // Clear previous board
                gameBoard.appendChild(playerElement); // Ensure player is inside
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        const tile = document.createElement('div');
                        tile.id = `tile-${c}-${r}`;
                        tile.classList.add('tile');
                        // Classes are now for logic, not styling the tile itself
                        if (tileData[r][c] === 1) tile.classList.add('wall');
                        if (tileData[r][c] === 3) tile.classList.add('target');
                        gameBoard.appendChild(tile);
                    }
                }
            }

            /**
             * Finds the starting position from the tileData array.
             */
            function findStartPosition() {
                for (let r = 0; r < GRID_HEIGHT; r++) {
                    for (let c = 0; c < GRID_WIDTH; c++) {
                        if (tileData[r][c] === 2) {
                            return { x: c, y: r };
                        }
                    }
                }
                return { x: 1, y: 1 }; // Fallback
            }

            /**
             * Updates the player's visual position and rotation on the grid.
             */
            function renderPlayer() {
                // Player sprite is a triangle pointing up, so we offset rotation by -90deg
                // 0(Up)=0deg, 1(Right)=90deg, 2(Down)=180deg, 3(Left)=270deg
                const rotation = player.dir * 90;
                playerElement.style.left = `${player.x * TILE_SIZE}px`;
                playerElement.style.top = `${player.y * TILE_SIZE}px`;
                playerElement.style.transform = `rotate(${rotation}deg)`;
            }

            /**
             * Updates the display of the command queue.
             */
            function renderQueue() {
                if (commandQueue.length === 0) {
                    queueDisplay.innerHTML = 'Queue is empty.';
                    return;
                }
                queueDisplay.innerHTML = commandQueue.map(cmd => {
                    const icons = { move: '‚Üë', rotR: '‚Ü∑', rotL: '‚Ü∂', affect: 'üí•' };
                    return `<span class="inline-block text-lg bg-gray-700 rounded px-2 py-1">${icons[cmd]}</span>`;
                }).join('');
            }
            
            /**
             * Adds a command to the queue.
             * @param {string} command - The command to add ('move', 'rotR', 'rotL', 'affect').
             */
            function queueCommand(command) {
                if (isExecuting) return; // Don't add commands while running
                commandQueue.push(command);
                renderQueue();
            }

            /**
             * Executes the command queue sequentially with delays.
             */
            function executeQueue() {
                if (isExecuting || commandQueue.length === 0) return;
                isExecuting = true;
                
                const intervalId = setInterval(() => {
                    if (commandQueue.length === 0) {
                        clearInterval(intervalId);
                        isExecuting = false;
                        return;
                    }

                    const command = commandQueue.shift();
                    renderQueue(); // Update display as queue empties
                    
                    switch (command) {
                        case 'move':
                            handleMove();
                            break;
                        case 'rotR':
                            player.dir = (player.dir + 1) % 4;
                            break;
                        case 'rotL':
                            player.dir = (player.dir - 1 + 4) % 4;
                            break;
                        case 'affect':
                            handleAffect();
                            break;
                    }
                    renderPlayer();

                }, 400); // 400ms delay between commands
            }
            
            /**
             * Logic for handling player movement.
             */
            function handleMove() {
                let nextX = player.x;
                let nextY = player.y;

                if (player.dir === 0) nextY--; // Up
                if (player.dir === 1) nextX++; // Right
                if (player.dir === 2) nextY++; // Down
                if (player.dir === 3) nextX--; // Left

                // Collision detection
                if (nextX >= 0 && nextX < GRID_WIDTH && nextY >= 0 && nextY < GRID_HEIGHT && tileData[nextY][nextX] !== 1) {
                    player.x = nextX;
                    player.y = nextY;
                }
            }

            /**
             * Logic for handling the 'affect' command.
             */
            function handleAffect() {
                const currentTile = document.getElementById(`tile-${player.x}-${player.y}`);
                if (currentTile && currentTile.classList.contains('target')) {
                    currentTile.classList.add('target-affected');
                    showWinModal();
                }
            }
            
            /**
             * Shows the win condition modal.
             */
            function showWinModal() {
                 setTimeout(() => {
                    winModal.classList.remove('hidden');
                    setTimeout(() => winModal.classList.remove('opacity-0'), 10);
                }, 500); // Delay to appreciate the final move
            }

            /**
             * Resets the game to its initial state.
             */
            function resetGame() {
                // Hide modal
                winModal.classList.add('opacity-0');
                setTimeout(() => winModal.classList.add('hidden'), 300);

                // Clear queue and state
                commandQueue = [];
                isExecuting = false;
                
                // Reset player position and board visuals
                const startPos = findStartPosition();
                player = { x: startPos.x, y: startPos.y, dir: 0 };
                createBoard(); // This will also remove 'target-affected' class from the old tile
                renderPlayer();
                renderQueue();
            }

            // --- EVENT LISTENERS ---
            document.getElementById('btn-move').addEventListener('click', () => queueCommand('move'));
            document.getElementById('btn-rotR').addEventListener('click', () => queueCommand('rotR'));
            document.getElementById('btn-rotL').addEventListener('click', () => queueCommand('rotL'));
            document.getElementById('btn-affect').addEventListener('click', () => queueCommand('affect'));
            
            document.getElementById('btn-run').addEventListener('click', executeQueue);
            document.getElementById('btn-clear').addEventListener('click', () => {
                if(isExecuting) return;
                commandQueue = [];
                renderQueue();
            });
            document.getElementById('btn-reset').addEventListener('click', resetGame);


            // --- INITIALIZATION ---
            function init() {
                const startPos = findStartPosition();
                player.x = startPos.x;
                player.y = startPos.y;
                createBoard();
                renderPlayer();
                renderQueue();
            }

            init();
        });
    </script>
</body>
</html>
